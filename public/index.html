<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flappy Turd</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at 20% 20%, #3a2f3d, #120b18) fixed;
      color: #f4f1f0;
      padding: 1rem;
    }
    .card {
      width: min(620px, 100%);
      padding: 1.75rem;
      background: rgba(16, 12, 22, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 22px;
      box-shadow:
        0 25px 60px rgba(0, 0, 0, 0.45),
        inset 0 0 30px rgba(255, 255, 255, 0.02);
      backdrop-filter: blur(12px);
    }
    h1 {
      margin: 0 0 0.5rem;
      font-size: clamp(2rem, 3vw, 2.8rem);
      letter-spacing: 0.04em;
      text-shadow: 0 4px 16px rgba(0,0,0,0.55);
    }
    canvas {
      width: 100%;
      aspect-ratio: 21 / 32;
      border-radius: 18px;
      background: linear-gradient(#65c8ff, #8fe5ff 45%, #9ae890 60%, #7dc262);
      display: block;
      margin: 1.25rem 0;
      border: 1px solid rgba(0, 0, 0, 0.2);
      box-shadow: inset 0 6px 24px rgba(0,0,0,0.35);
      image-rendering: pixelated;
      cursor: pointer;
      touch-action: manipulation;
    }
    p {
      margin: 0.35rem 0;
      line-height: 1.6;
      font-size: 1rem;
    }
    small {
      opacity: 0.75;
      font-size: 0.85rem;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem 1rem;
      font-size: 0.95rem;
      opacity: 0.85;
    }
    .btn-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }
    button {
      border: none;
      border-radius: 999px;
      padding: 0.55rem 1.25rem;
      font-size: 0.95rem;
      font-weight: 600;
      background: linear-gradient(135deg, #fca311, #f97316);
      color: #fff;
      cursor: pointer;
      box-shadow: 0 5px 18px rgba(249, 115, 22, 0.4);
      transition: transform 150ms ease, box-shadow 150ms ease;
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 9px 22px rgba(249, 115, 22, 0.5);
    }
    button:active {
      transform: translateY(1px);
      box-shadow: 0 4px 12px rgba(249, 115, 22, 0.45);
    }
  </style>
</head>
<body>
  <main class="card">
    <h1>ðŸ’© Flappy Turd</h1>
    <canvas id="game" width="420" height="640" aria-label="Flappy Turd canvas"></canvas>
    <div class="btn-row">
      <p class="controls">
        <strong>Controls:</strong>
        <span>Space / Click / Tap to flap</span>
      </p>
      <button id="restart">Restart</button>
    </div>
    <p>
      Larger pipes, calmer gravity, and a more realistic swirl make this version way more forgiving. Float your majestic turd through the sewer vents, rack up points, and try to keep thingsâ€¦ tidy.
    </p>
    <small>Tip: gentle, rhythmic taps keep altitude. Holding space is a recipe for splat.</small>
  </main>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const restartBtn = document.getElementById('restart');

    const WORLD = { width: canvas.width, height: canvas.height };
    const FLOOR_HEIGHT = 40;
    const GRAVITY = 0.24;
    const FLAP = -5.4;
    const PIPE_GAP = 180;
    const PIPE_WIDTH = 70;
    const PIPE_SPACING = 260;
    const BASE_SPEED = 1.6;
    const SPEED_RAMP = 0.035;
    const MAX_SPEED = 2.6;

    let turd, pipes, score, highScore, particles;
    let gameState = 'ready'; // 'ready' | 'running' | 'over'
    let lastTime = 0;

    const poop = new Image();
    const poopReady = new Promise(resolve => {
      poop.addEventListener('load', resolve, { once: true });
    });
    // Hand-drawn poop swirl sprite (SVG data URL)
    poop.src = 'data:image/svg+xml;utf8,' + encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
        <defs>
          <radialGradient id="poopShade" cx="50%" cy="30%" r="70%">
            <stop offset="0%" stop-color="#7a4926" />
            <stop offset="55%" stop-color="#5b3314" />
            <stop offset="95%" stop-color="#2b1407" />
          </radialGradient>
          <linearGradient id="poopGloss" x1="20%" x2="60%" y1="20%" y2="60%">
            <stop offset="0%" stop-color="#fff" stop-opacity="0.4"/>
            <stop offset="80%" stop-color="#fff" stop-opacity="0"/>
          </linearGradient>
        </defs>
        <rect width="200" height="200" rx="36" fill="#1b130e"/>
        <g filter="url(#shadow)">
          <path d="M78 56c-10 12-4 20-22 28s-24 24-24 39c0 23 21 41 48 41s48-18 48-41c0-12-6-29-24-35 8-7 11-22-4-32s-20-3-22 0z" fill="url(#poopShade)"/>
          <path d="M126 66c4 8 2 17-5 23c15 4 32 18 32 42c0 27-24 49-54 49s-54-22-54-49" fill="none" stroke="#2d1809" stroke-width="10" stroke-linecap="round"/>
          <path d="M86 82c-6 10-5 19-22 23" stroke="#2f180a" stroke-width="9" stroke-linecap="round"/>
          <ellipse cx="96" cy="150" rx="52" ry="18" fill="#000" opacity="0.25"/>
        </g>
        <ellipse cx="86" cy="102" rx="12" ry="14" fill="#fff" opacity="0.9"/>
        <ellipse cx="116" cy="102" rx="12" ry="14" fill="#fff" opacity="0.9"/>
        <circle cx="86" cy="102" r="6" fill="#0a0502"/>
        <circle cx="116" cy="102" r="6" fill="#0a0502"/>
        <path d="M82 132c8 7 28 7 36 0" stroke="#160b05" stroke-width="8" stroke-linecap="round" fill="none"/>
        <path d="M92 70c-10-3-18 0-26 9" stroke="url(#poopGloss)" stroke-width="8" stroke-linecap="round"/>
      </svg>
    `);

    function resetGame() {
      turd = {
        x: WORLD.width * 0.3,
        y: WORLD.height / 2,
        radius: 22,
        vel: 0,
        rotation: 0,
      };
      pipes = [];
      particles = [];
      score = 0;
      gameState = 'ready';
      spawnPipe(true);
      spawnPipe();
    }

    function spawnPipe(initial = false) {
      const lastX = pipes.length ? pipes[pipes.length - 1].x : WORLD.width;
      const spawnX = initial ? WORLD.width + 200 : Math.max(lastX + PIPE_SPACING, WORLD.width + PIPE_WIDTH);
      const gapY = 90 + Math.random() * (WORLD.height - FLOOR_HEIGHT - PIPE_GAP - 160);
      const speed = Math.min(BASE_SPEED + score * SPEED_RAMP, MAX_SPEED);
      pipes.push({
        x: spawnX,
        gapY,
        speed,
        passed: false,
      });
    }

    function flap() {
      if (gameState === 'ready') {
        gameState = 'running';
      }
      if (gameState !== 'running') return;
      turd.vel = FLAP;
      spawnParticles();
    }

    function spawnParticles() {
      const count = 5;
      for (let i = 0; i < count; i++) {
        particles.push({
          x: turd.x - turd.radius * 0.6,
          y: turd.y + turd.radius * 0.5,
          vx: -1 - Math.random() * 1.2,
          vy: (Math.random() - 0.5) * 1.1,
          life: 40 + Math.random() * 30,
          size: 3 + Math.random() * 3,
        });
      }
    }

    function update() {
      if (gameState !== 'running') return;

      turd.vel += GRAVITY;
      turd.y += turd.vel;
      turd.rotation = Math.atan2(turd.vel, 10);

      if (turd.y + turd.radius > WORLD.height - FLOOR_HEIGHT) {
        turd.y = WORLD.height - FLOOR_HEIGHT - turd.radius;
        return gameOver();
      }
      if (turd.y - turd.radius < 0) {
        turd.y = turd.radius;
        turd.vel = 0;
      }

      pipes.forEach(pipe => {
        pipe.x -= pipe.speed;
        if (!pipe.passed && pipe.x + PIPE_WIDTH < turd.x - turd.radius) {
          pipe.passed = true;
          score += 1;
          if (score % 4 === 0) spawnParticles();
        }
      });

      if (pipes.length && pipes[0].x + PIPE_WIDTH < -20) {
        pipes.shift();
        spawnPipe();
      }

      for (const pipe of pipes) {
        if (rectCircleCollide(turd, pipe)) {
          return gameOver();
        }
      }

      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 1;
        p.vy += 0.015;
        return p.life > 0;
      });
    }

    function rectCircleCollide(circle, pipe) {
      const topRect = { x: pipe.x, y: 0, width: PIPE_WIDTH, height: pipe.gapY };
      const bottomRect = {
        x: pipe.x,
        y: pipe.gapY + PIPE_GAP,
        width: PIPE_WIDTH,
        height: WORLD.height - (pipe.gapY + PIPE_GAP),
      };
      return [topRect, bottomRect].some(rect => {
        const nearestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
        const nearestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
        const dx = circle.x - nearestX;
        const dy = circle.y - nearestY;
        return dx * dx + dy * dy <= circle.radius * circle.radius;
      });
    }

    function gameOver() {
      gameState = 'over';
      highScore = Math.max(highScore, score);
      localStorage.setItem('flappyTurdHighScore', String(highScore));
    }

    function drawBackground() {
      const horizon = WORLD.height * 0.55;
      const gradient = ctx.createLinearGradient(0, 0, 0, horizon);
      gradient.addColorStop(0, '#7fd3ff');
      gradient.addColorStop(1, '#c8f7ff');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, WORLD.width, horizon);

      ctx.fillStyle = '#7dc262';
      ctx.fillRect(0, horizon, WORLD.width, WORLD.height - horizon - FLOOR_HEIGHT);
      ctx.fillStyle = '#4d5620';
      ctx.fillRect(0, WORLD.height - FLOOR_HEIGHT, WORLD.width, FLOOR_HEIGHT);
    }

    function drawPipes() {
      pipes.forEach(pipe => {
        const topHeight = pipe.gapY;
        const bottomY = pipe.gapY + PIPE_GAP;
        ctx.fillStyle = '#4d3a24';
        ctx.fillRect(pipe.x, 0, PIPE_WIDTH, topHeight);
        ctx.fillRect(pipe.x, bottomY, PIPE_WIDTH, WORLD.height - bottomY);

        ctx.fillStyle = '#2f2415';
        ctx.fillRect(pipe.x - 5, topHeight - 16, PIPE_WIDTH + 10, 16);
        ctx.fillRect(pipe.x - 5, bottomY, PIPE_WIDTH + 10, 16);
      });
    }

    function drawTurd() {
      ctx.save();
      ctx.translate(turd.x, turd.y);
      ctx.rotate(turd.rotation);
      ctx.drawImage(poop, -turd.radius * 1.4, -turd.radius * 1.4, turd.radius * 2.8, turd.radius * 2.8);
      ctx.restore();
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.globalAlpha = Math.max(p.life / 50, 0);
        ctx.fillStyle = '#b7813a';
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    }

    function drawHUD() {
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 30px "Inter", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(`Score: ${score}`, WORLD.width / 2, 48);
      ctx.font = '18px "Inter", sans-serif';
      ctx.fillText(`Best: ${highScore}`, WORLD.width / 2, 78);
    }

    function drawOverlay(text, subtext) {
      ctx.fillStyle = 'rgba(0,0,0,0.45)';
      ctx.fillRect(40, WORLD.height / 2 - 70, WORLD.width - 80, 140);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(40, WORLD.height / 2 - 70, WORLD.width - 80, 140);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px "Inter", sans-serif';
      ctx.fillText(text, WORLD.width / 2, WORLD.height / 2 - 10);
      ctx.font = '16px "Inter", sans-serif';
      ctx.fillText(subtext, WORLD.width / 2, WORLD.height / 2 + 30);
    }

    function draw() {
      ctx.clearRect(0, 0, WORLD.width, WORLD.height);
      drawBackground();
      drawPipes();
      drawParticles();
      drawTurd();
      drawHUD();

      if (gameState === 'ready') {
        drawOverlay('Tap / click / press space to flap', 'The sewer breeze is gentle now.');
      } else if (gameState === 'over') {
        drawOverlay('SPLAT! Press space to retry', 'You can do better than that.');
      }
    }

    function loop(timestamp) {
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      if (delta < 1000) {
        update(delta);
      }
      draw();
      requestAnimationFrame(loop);
    }

    async function init() {
      highScore = parseInt(localStorage.getItem('flappyTurdHighScore') || '0', 10);
      await poopReady;
      resetGame();
      requestAnimationFrame(loop);
    }

    canvas.addEventListener('pointerdown', flap);
    canvas.addEventListener('pointerup', e => e.preventDefault());
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (gameState === 'over') {
          resetGame();
        }
        flap();
      }
      if (e.code === 'KeyR') {
        e.preventDefault();
        resetGame();
        gameState = 'running';
        turd.vel = FLAP;
      }
    });

    restartBtn.addEventListener('click', () => {
      resetGame();
      gameState = 'running';
      turd.vel = FLAP;
    });

    window.addEventListener('click', () => {
      if (gameState === 'over') {
        resetGame();
        gameState = 'running';
        turd.vel = FLAP;
      }
    });

    window.addEventListener('blur', () => {
      if (gameState === 'running') {
        gameState = 'ready';
      }
    });

    init();
  </script>
</body>
</html>
